import logging
from fastapi import APIRouter, HTTPException, Request, Query
from sqlalchemy.exc import IntegrityError
from psycopg2.errors import UniqueViolation
from typing import List, Optional, Dict, Any
from uuid import UUID

from app.schemas.{{ table_name }} import (
    {{ table_name|capitalize }}Create,
    {{ table_name|capitalize }}Update,
    {{ table_name|capitalize }}Response
)
from app.use_cases.create_{{ table_name }} import Create{{ table_name|capitalize }}
from app.use_cases.update_{{ table_name }} import Update{{ table_name|capitalize }}
from app.use_cases.get_{{ table_name }} import Get{{ table_name|capitalize }}
from app.use_cases.delete_{{ table_name }} import Delete{{ table_name|capitalize }}
from app.use_cases.search_{{ table_name }} import Search{{ table_name|capitalize }}

logger = logging.getLogger(__name__)

def get_{{ table_name }}_router(relational_db):
    router = APIRouter()

    @router.get("/", response_model=Dict[str, Any])
    def search_{{ table_name }}s(
        request: Request,
        limit: int = Query(20, ge=1, le=100),
        offset: int = Query(0, ge=0)
    ):
        """
        Paginated search for {{ table_name }}s.
        """
        filters = dict(request.query_params)
        filters.pop("limit", None)
        filters.pop("offset", None)
        logger.info(f"Searching {{ table_name }}s with filters={filters}, limit={limit}, offset={offset}")
        try:
            results, total = Search{{ table_name|capitalize }}(relational_db).execute(limit=limit, offset=offset, **filters)
            results = [{{ table_name|capitalize }}Response.model_validate(obj) for obj in results]
            logger.info(f"Found {len(results)} {{ table_name }}s (total={total})")
            return {
                "results": results,
                "limit": limit,
                "offset": offset,
                "total": total
            }
        except Exception as e:
            logger.exception(f"Exception during search for {{ table_name }}s: {e}")
            raise HTTPException(status_code=500, detail="Internal server error during search")

    @router.get("/{item_id}", response_model={{ table_name|capitalize }}Response)
    def get_{{ table_name }}(item_id: {% if table_name == 'workspace' %}int{% else %}UUID{% endif %}):
        logger.info(f"Fetching {{ table_name }} with id={item_id}")
        result = Get{{ table_name|capitalize }}(relational_db).execute(item_id)
        if result is None:
            logger.warning(f"{{ table_name|capitalize }} with id={item_id} not found")
            raise HTTPException(status_code=404, detail="{{ table_name|capitalize }} not found")
        return result

    @router.post("/", response_model={{ table_name|capitalize }}Response)
    def create_{{ table_name }}(payload: {{ table_name|capitalize }}Create):
        logger.info(f"Creating new {{ table_name }} with payload={payload.dict()}")
        try:
            obj = Create{{ table_name|capitalize }}(relational_db).execute(payload)
            return obj
        except ValueError as e:
            logger.warning(f"HTTP error 400: {e} | Path: /")
            raise HTTPException(status_code=400, detail=str(e))
        except IntegrityError as e:
            if isinstance(e.orig, UniqueViolation):
                # Extract column name from error message for better user feedback
                error_msg = str(e.orig)
                if "Key (" in error_msg and ")=" in error_msg:
                    # Extract field name from "Key (field_name)=(value) already exists"
                    field_name = error_msg.split("Key (")[1].split(")=")[0]
                    field_value = error_msg.split(")=(")[1].split(") already exists")[0]
                    detail = f"The {field_name} '{field_value}' is already in use. Please choose a different value."
                else:
                    detail = "A unique constraint was violated. Please check your input values."
                logger.warning(f"Unique constraint violation during create: {detail}")
                raise HTTPException(status_code=400, detail=detail)
            logger.error(f"Integrity error during create: {str(e.orig)}")
            raise HTTPException(status_code=400, detail=str(e.orig).split("\n")[0])
        except Exception as e:
            logger.exception(f"Exception during create for {{ table_name }}: {e}")
            raise HTTPException(status_code=500, detail="Internal server error during create")

    @router.put("/{item_id}", response_model={{ table_name|capitalize }}Response)
    def update_{{ table_name }}(item_id: {% if table_name == 'workspace' %}int{% else %}UUID{% endif %}, payload: {{ table_name|capitalize }}Update):
        logger.info(f"Updating {{ table_name }} with id={item_id}, payload={payload.dict(exclude_unset=True)}")
        try:
            updated = Update{{ table_name|capitalize }}(relational_db).execute(item_id, payload)
        except IntegrityError as e:
            if isinstance(e.orig, UniqueViolation):
                # Extract column name from error message for better user feedback
                error_msg = str(e.orig)
                if "Key (" in error_msg and ")=" in error_msg:
                    # Extract field name from "Key (field_name)=(value) already exists"
                    field_name = error_msg.split("Key (")[1].split(")=")[0]
                    field_value = error_msg.split(")=(")[1].split(") already exists")[0]
                    detail = f"The {field_name} '{field_value}' is already in use. Please choose a different value."
                else:
                    detail = "A unique constraint was violated. Please check your input values."
                logger.warning(f"Unique constraint violation during update: {detail}")
                raise HTTPException(status_code=400, detail=detail)
            logger.error(f"Integrity error during update: {str(e.orig)}")
            raise HTTPException(status_code=400, detail=str(e.orig).split("\n")[0])
        except Exception as e:
            logger.exception(f"Exception during update for {{ table_name }} with id={item_id}: {e}")
            raise HTTPException(status_code=500, detail="Internal server error during update")
        if updated is None:
            logger.warning(f"Update failed: {{ table_name }} with id={item_id} not found")
            raise HTTPException(status_code=404, detail="{{ table_name|capitalize }} not found")
        return updated

    @router.delete("/{item_id}")
    def delete_{{ table_name }}(item_id: {% if table_name == 'workspace' %}int{% else %}UUID{% endif %}):
        logger.info(f"Deleting {{ table_name }} with id={item_id}")
        try:
            deleted = Delete{{ table_name|capitalize }}(relational_db).execute(item_id)
            if not deleted:
                logger.warning(f"Delete failed: {{ table_name }} with id={item_id} not found")
                raise HTTPException(status_code=404, detail="{{ table_name|capitalize }} not found")
            logger.info(f"Deleted {{ table_name }} with id={item_id}")
            return {"detail": "{{ table_name|capitalize }} deleted"}
        except Exception as e:
            logger.exception(f"Exception during delete for {{ table_name }} with id={item_id}: {e}")
            raise HTTPException(status_code=500, detail="Internal server error during delete")

    return router
