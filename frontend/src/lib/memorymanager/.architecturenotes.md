# Ergolux Data Architecture & Caching Strategy

## Overview

Ergolux implements a sophisticated multi-layer caching architecture designed to deliver sub-millisecond response times for real estate transaction professionals. The system prioritizes speed through aggressive local caching while maintaining data consistency across geographically distributed deployments.

## Core Architecture Principles

### 1. Geographic Distribution with Centralized Data

```
User → Local Web-BFF (Redis Cache) → Remote Microservices (PostgreSQL)
  ↓
Fast Local Cache ←→ Eventual Consistency ←→ Source of Truth
```

### 2. Multi-Layer Caching Hierarchy

```
Browser Storage (0-5ms)
    ↓
Web-BFF Redis (10-50ms)
    ↓
Microservice Databases (100-500ms+)
```

## Data Storage Layers

### Layer 1: Browser Storage (Immediate Access)

#### localStorage (Key-Value Data)

- **Purpose**: Critical user data requiring instant access
- **Performance**: ~1ms response time
- **Capacity**: ~10MB per domain
- **Content**:
  ```json
  {
    "user_profile": {
      "id": "uuid",
      "first_name": "John",
      "last_name": "Doe",
      "email": "john@example.com",
      "preferences": {...},
      "last_sync": "2024-01-15T10:30:00Z"
    },
    "workspace_settings": {
      "current_workspace": "uuid",
      "layout_preferences": {...},
      "quick_access_contacts": [...]
    },
    "recent_transactions": [...],
    "dashboard_metrics": {
      "cached_at": "timestamp",
      "data": {...}
    }
  }
  ```

#### IndexedDB (Complex Queries)

- **Purpose**: Bulk data storage with query capabilities
- **Performance**: ~10-50ms response time
- **Capacity**: ~50% of available disk space
- **Content**:
  - Full contact database with search indexes
  - Transaction history with filtering capabilities
  - Document metadata and thumbnails
  - Property listings with geographic data
  - Communication logs and notes

#### Svelte Stores (In-Memory)

- **Purpose**: Active session data for reactive UI
- **Performance**: ~0.001ms response time
- **Content**:
  ```javascript
  $userStore = { ...current user state }
  $contactsStore = { ...filtered/active contacts }
  $dashboardStore = { ...live dashboard metrics }
  $workspaceStore = { ...current workspace data }
  $notificationsStore = { ...real-time updates }
  ```

### Layer 2: Web-BFF Redis Cache

#### Caching Strategy

- **Geographic proximity**: Multiple Web-BFF instances with local Redis
- **Cache TTL by data type**:
  - User profiles: 24 hours
  - Contact data: 1 hour
  - Dashboard metrics: 5 minutes
  - Search results: 15 minutes
- **Invalidation**: Pub/sub messaging for real-time updates

#### Data Organization

```redis
user:{user_id}:profile = {...}
user:{user_id}:workspaces = [...]
workspace:{workspace_id}:contacts = [...]
workspace:{workspace_id}:transactions = [...]
search:{query_hash} = {...}
dashboard:{workspace_id}:metrics = {...}
```

### Layer 3: Microservice Databases

#### Service-Specific Storage

- **Auth Service**: User credentials, sessions, tokens
- **Human Service**: Contact profiles, relationships, communication history
- **Workspace Service**: Organization data, permissions, settings
- **Location Service**: Property data, geographic information
- **Transaction Service**: Deal progress, documents, timelines

## Background Data Synchronization

### Continuous Sync Service

```javascript
class DataSyncService {
  constructor() {
    this.syncInterval = 30000; // 30 seconds
    this.priorities = {
      user_profile: 1,
      active_transactions: 2,
      contacts: 3,
      historical_data: 4,
    };
  }

  async syncUserData() {
    const cached = this.getLocalData("user_profile");
    const lastSync = cached?.last_sync || 0;

    // Check web-BFF for updates since last sync
    const updates = await fetch(`/api/sync/user?since=${lastSync}`);

    if (updates.has_changes) {
      await this.updateLocalData(updates.data);
      this.notifyStores(updates.data);
    }
  }

  startBackgroundSync() {
    // Sync on interval
    setInterval(() => this.syncUserData(), this.syncInterval);

    // Sync on page focus
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) this.syncUserData();
    });

    // Predictive loading based on user behavior
    this.predictiveSync();
  }
}
```

### Data Prioritization Strategy

#### Priority Levels

1. **Critical (Immediate)**: Current user profile, active workspace
2. **High (Pre-load)**: Recent contacts, active transactions
3. **Medium (Background)**: Contact search indexes, dashboard metrics
4. **Low (On-demand)**: Historical data, archived transactions

#### Smart Caching Logic

```javascript
// Pre-load likely next interactions
const preloadStrategy = {
  dashboard_view: [
    "recent_transactions",
    "contact_activity",
    "pipeline_metrics",
  ],
  contact_list: ["contact_search_index", "recent_communications"],
  transaction_detail: [
    "related_contacts",
    "document_metadata",
    "timeline_data",
  ],
};
```

## Performance Optimization Patterns

### Search & Query Optimization

#### Contact Search

```javascript
// Pre-indexed search using Fuse.js
$contactsStore = derived(contactsCache, ($cache) => {
  const fuse = new Fuse($cache, {
    keys: ["first_name", "last_name", "email", "company"],
    threshold: 0.3,
  });

  return {
    search: (query) => fuse.search(query), // ~5-20ms
    recent: $cache.filter((c) => c.last_contact > Date.now() - 604800000),
    favorites: $cache.filter((c) => c.is_favorite),
    byWorkspace: (workspace_id) =>
      $cache.filter((c) => c.workspace_id === workspace_id),
  };
});
```

#### Dashboard Metrics

```javascript
// Pre-calculated metrics updated in background
const dashboardCache = {
  contact_activity: {
    data: computed_in_background,
    ttl: 300000, // 5 minutes
    last_update: timestamp,
  },
  revenue_trends: {
    data: cached_with_30min_ttl,
    ttl: 1800000, // 30 minutes
    last_update: timestamp,
  },
  pipeline_status: {
    data: real_time_updates,
    ttl: 60000, // 1 minute
    last_update: timestamp,
  },
};
```

### Storage Management

#### Intelligent Cache Eviction

```javascript
class StorageManager {
  constructor() {
    this.maxStorage = 8 * 1024 * 1024; // 8MB localStorage limit
    this.priorities = new Map();
  }

  store(key, data, priority = 3) {
    if (this.getStorageSize() + this.getDataSize(data) > this.maxStorage) {
      this.evictLowPriorityData();
    }

    localStorage.setItem(
      key,
      JSON.stringify({
        data,
        priority,
        lastAccessed: Date.now(),
        size: this.getDataSize(data),
      })
    );
  }

  evictLowPriorityData() {
    // LRU eviction with priority weighting
    const items = this.getAllItems().sort(
      (a, b) => a.priority * a.lastAccessed - b.priority * b.lastAccessed
    );

    // Remove lowest priority, least recently used items
    while (this.getStorageSize() > this.maxStorage * 0.8) {
      const item = items.shift();
      localStorage.removeItem(item.key);
    }
  }
}
```

## Real-Time Data Updates

### WebSocket Integration

```javascript
// Real-time updates for critical data changes
websocket.on("user_profile_updated", (data) => {
  updateLocalStorage("user_profile", data);
  userStore.set(data);
});

websocket.on("transaction_status_changed", (data) => {
  updateIndexedDB("transactions", data);
  transactionStore.update((store) => ({
    ...store,
    [data.id]: data,
  }));
});

websocket.on("cache_invalidate", (keys) => {
  keys.forEach((key) => {
    localStorage.removeItem(key);
    invalidateStore(key);
  });
});
```

### Optimistic Updates

```javascript
// Update UI immediately, sync in background
async function updateContact(contactId, changes) {
  // Immediate UI update
  contactsStore.update((contacts) =>
    contacts.map((c) => (c.id === contactId ? { ...c, ...changes } : c))
  );

  // Background sync
  try {
    const result = await api.updateContact(contactId, changes);
    // Update with server response if different
    if (JSON.stringify(result) !== JSON.stringify(changes)) {
      contactsStore.update((contacts) =>
        contacts.map((c) => (c.id === contactId ? result : c))
      );
    }
  } catch (error) {
    // Revert on failure
    contactsStore.update((contacts) =>
      contacts.map((c) => (c.id === contactId ? originalContact : c))
    );
    showError("Update failed - changes reverted");
  }
}
```

## Data Consistency & Conflict Resolution

### Conflict Resolution Strategy

1. **Last-write-wins** for simple updates
2. **User notification** for complex conflicts
3. **Automatic merge** for non-conflicting changes
4. **Manual resolution** for critical business data

### Version Control

```javascript
// Simple versioning for conflict detection
const dataWithVersion = {
  id: 'contact_123',
  data: { ... },
  version: 15,
  last_modified: '2024-01-15T10:30:00Z',
  modified_by: 'user_456'
};
```

## Security Considerations

### Local Data Protection

- **No sensitive authentication data** in browser storage
- **Encrypted storage** for business-critical information
- **Automatic cleanup** on logout/session expiry
- **User-scoped encryption keys** for multi-tenant data

### Cache Invalidation Security

- **Signed invalidation messages** to prevent cache poisoning
- **Rate limiting** on sync endpoints
- **Workspace isolation** in all cached data

## Performance Targets & Monitoring

### Response Time Goals

| Operation         | Target | Fallback |
| ----------------- | ------ | -------- |
| User profile load | <1ms   | <50ms    |
| Contact search    | <20ms  | <200ms   |
| Dashboard load    | <100ms | <500ms   |
| Transaction list  | <50ms  | <300ms   |
| Document preview  | <200ms | <1000ms  |

### Monitoring Metrics

- Cache hit rates by data type
- Storage utilization trends
- Sync success rates
- User-perceived response times
- Offline capability metrics

This architecture delivers **"fast as hell"** performance by ensuring 90%+ of user interactions hit local caches, with seamless background synchronization maintaining data freshness across all geographic deployments.
